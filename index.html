<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " vocab="http://ogp.me/ns" lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="Serving you via log, lead &amp; lookout">
<meta name="viewport" content="width=device-width">
<title>Gabriel Pickard</title>
<link href="assets/css/rst.css" rel="stylesheet" type="text/css">
<link href="assets/css/code.css" rel="stylesheet" type="text/css">
<link href="assets/css/theme.css" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="assets/css/main.css">
<link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:300%7CMontserrat:700" rel="stylesheet" type="text/css">
<link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
<script src="//code.jquery.com/jquery-1.10.2.min.js"></script><link href="assets/css/custom.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">
<link rel="canonical" href="https://www.gabrielpickard.com/">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]--><link rel="prefetch" href="posts/programming-languages-shouldnt-and-neednt-be-turing-complete/" type="text/html">
</head>
<body><main><!--[if lt IE 7]><p class="browsehappy">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> or <a href="http://www.google.com/chrome/‎">install Google Chrome</a> to experience this site.</p><![endif]--><header id="site-header"><div class="container">
            <a href="#"><h1 class="blog-title heading">Gabriel Pickard</h1></a>
            <p class="blog-description">Serving you via log, lead &amp; lookout</p>

            <nav id="menu"><ul>
<li><a href="pages/about/">About</a></li>
                <li><a href="https://twitter.com/werg">Twitter</a></li>
                <li><a href="https://github.com/werg">Github</a></li>
                <li><a href="archive.html">Archive</a></li>
                <li><a href="rss.xml">RSS</a></li>
            </ul></nav>
</div>
    </header><main class="content" role="main"><div class="container">

            

    

<article class="li post"><header class="post-header"><h3 class="post-title"><a href="posts/programming-languages-shouldnt-and-neednt-be-turing-complete/">Programming languages shouldn't and needn't be Turing complete</a></h3>
        <p class="post-time"><time datetime="2020-12-09T18:25:19-05:00">2020-12-09 18:25</time>
        by
                Gabriel Pickard
        </p>
    </header><section class="post-excerpt"><p>As we software engineers grow up, we are taught early on (like in kindergarten) to associate Turing (equivalent) machines with computation <em>per se</em>: It's the paradigm that the vast majority of programming languages aspire to and that many more which don't aspire to fall into <a href="https://beza1e1.tuxen.de/articles/accidentally_turing_complete.html">accidentally</a>. If you grew up like me, you probably came to believe that Turing completeness was necessary to build any serious programs and that Turing incomplete languages were either toys, parsing tools or config files. Well -- you maybe heard that <em>SQL</em> was Turing incomplete but not thought much of it.</p>
<p>Well, I have come to tell you that these matters aren't quite the way they seem: Turing incomplete languages can in fact be powerful enough to support pretty much any programming task you or I or any web developer, or data scientist, or devops engineer would be faced with today. I will also tell you that Turing incompleteness is very promising to drive a true leap forward in the art of software engineering, on par with the likes of garbage collection or structured programming.</p>
<p>The goal is to leverage Turing incompleteness for:</p>
<ul>
<li>safe collaborative sandboxing</li>
<li>predictable "serverless" cloud functions</li>
<li>distriuted computing with provably less bugs </li>
<li>cryptocurrency "smart contracts" less full of money-losing surprises</li>
<li>tractable automatic code generation from specification</li>
<li>safer interaction of untrusted components</li>
</ul>
<p>While the path to getting there is not completely clear, Turing incompleteness is both promising and easy enough to warrant much more intense investigation and experimentation than we currently have. In service of more widespread adoption we shall go through some very simple <em>dos and don'ts</em> for Turing incomplete languages which hopefully will inspire you to build your own!</p>
<p><em>This post is an adaption of a <a href="https://www.gabrielpickard.com/turing-incomplete_edited.pdf">paper</a> and talk I gave at <a href="https://2020.splashcon.org/home/hatra-2020?plenary=Hide%20plenary%20sessions">HATRA 2020</a>, a workshop during the <a href="https://2020.splashcon.org/">SPLASH 2020</a> conference.</em></p>
<h3>Ceding power to gain control</h3>
<p>Computers do exactly what we tell them to do. Unfortunately human thinking is much less pedantic and we write programs which don't do what we think they should. These discrepancies are called <em>bugs</em> and I'm here to get rid of them. We may also encounter the opposite problem: We are faced with a complex code base that does <em>something</em> and we are tasked with changing it, without understanding what it <em>really does</em>. Either way, nobody sets out to write segfaulting code -- and yet we inevitably do <em>so long as the language allows it</em>... Which is why garbage collectors are so popular these days.</p>
<p>Hence the history of programming language design has been a history of removing powers which were considered harmful and replacing them with tamer, more manageable and automated constructs. Here are a few examples:</p>
<ul>
<li>Direct entry of binary code became assembly language.</li>
<li>Direct access to CPU registers and instructions gave way to higher level compilers in the ALGOL tradition.</li>
<li>The infamous <em>GOTO</em> was banished in favor of structured programming.</li>
<li>Manual memory management is still around in certain areas, but garbage collection made memory safety so popular that now we have borrow checkers to write memory safe code even if we can't afford the garbage collector overhead.</li>
<li>OOP involved moving from arbitrary access to information hiding modularization.</li>
<li>Functional programming afficionados removed side-effects and mutability in favor of pure functions and persistent data structures. Nowadays programming in <em>React</em> is much better with immutability.</li>
</ul>
<p>The list goes on and on... While not all application domains benefit from all the replacement steps above, it appears as if removing some expressive power can often enable a new kind of programming, even a new kind of application altogether. Unix was possible because of the <em>C</em> compiler. Photoshop could hardly have been built on the basis of <em>GOTO</em>. The <em>JavaScript</em> ecosystem would not have grown without garbage collection.</p>
<p>While we can't know exactly what the benefits will be, Turing incompleteness is a great candidate to achieve an <em>expansion in applicability</em> by reducing expressive powers. Furthermore, there is cause for high hopes: compared to most of the changes listed above, Turing incompleteness is more sweeping and more fundamental.</p>
<h3>A great leap forward</h3>
<p><a href="https://en.wikipedia.org/wiki/Rice%27s_theorem">Rice's theorem</a> states that we can't build automatic checkers that work on <em>all programs</em> of a Turing complete language to extract any non-trivial property. These kinds of non-trivial properties are exactly what we would be looking for if we want to equip languages with smarter developer tools and more in-depth feedback about correctness, runtime complexity, optimization and security.</p>
<p>These kinds of benefits have not gone <em>completely unnoticed</em>. There are some success stories out there, applying Turing incomplete languages. The main one that most people have dealt with is <em>SQL</em>. I posit that <em>SQL</em> would not have been as successful and widespread as it is, if database servers weren't as performant as they are -- and they wouldn't have been as performant if the input language had been less manageable, i.e. Turing complete.</p>
<p>In many ways we don't yet know exactly what the killer app for Turing incompleteness will be, but I do have some ideas for what I would like: Making the kind of stuff people do with fancy type systems more user-friendly. I want verification to become much more transparent and automatic. As anyone who has dealt with automation and transparent abstraction knows: It's easy to come away with a bad taste and it's all about the edge cases -- the parts that make the abstraction leaky. Turing incompleteness could be a very big step to cutting out the ege cases, making our abstractions more robust and making it easier and more widespread to build verification tools.</p>
<p>Nowadays mission critical applications like Microsoft Windows are automatically checked for bugs at great expense using SMT solvers. This process is laborious, incomplete and full of pitfalls, which is why hardly anyone does it who doesn't have to. I think we can find a way out of this by fundamentally rethinking our computing paradigm.</p>
<h3>What Turing incomplete languages can and can't do</h3>
<p>I performed a small literature search and found two (2!) problems known to theoretical computer science which we cannot implement in a known Turing incomplete language. They are the following:</p>
<ul>
<li>Simulating a Turing machine (and equivalents)</li>
<li>Building a self-interpreter for a language in itself, where the input code is a Gödel number (and there even is a <a href="http://compilers.cs.ucla.edu/popl16/popl16-full.pdf">big caveat</a> to this)</li>
</ul>
<p>If you can think of any others, let me know, but suffice to say the list isn't long. Notably, the Ackermann function, SAT, A* etc., searching and sorting can all be solved using a strongly normalizing (i.e. terminating) lambda calculus like <a href="https://en.wikipedia.org/wiki/G%C3%B6del_system_T">Gödel's System T</a>.</p>
<p>While almost any known problem is clearly solvable in a known Turing incomplete language, the matter of <em>efficient algorithms</em> is  a different matter. Though it's clear that for <em>any specific given</em> problem we can come up with a set of Turing incomplete formalisms to model it efficiently, we cannot assume that there is <em>one</em> Turing incomplete language capable of representing <em>all</em> known algorithms as efficiently as <em>C/C++</em> would on a <em>von Neuman</em> style computer. There are some caveats. Luckily though, these issues are akin to how it's hard to represent an efficient mutate-in-place algorithm like as <em>quicksort</em> in a pure/immutable functional language like <em>Haskell</em> or <em>Clojure</em> -- and people still find a lot of use for those languages.</p>
<p>Algorithms of the type <em>"do X until condition Y holds"</em>, often found in numerical computing, which do not iterate over a collection, are hard to model in a Turing incomplete language. Doing so in the current state of the art requires complex type systems and proofs of termination which from my perspective take us farther from the goal of user friendly assisted programming..</p>
<p>Luckily, <em>the reality of modern application development</em> is often <em>extremely</em>, <em>extremely</em> light on "capital A algorithms". I.e. for very broad swaths of the software engineering workforce it is entirely irrelevant whether they can efficiently implement in-place sorting or the Newton-Raphson method. In fact, rolling your own fundamental algorithms is generally considered an anti-pattern and bad industry practice. That is what, by and large, we have libraries for. It's not by accident that many fundamental numerical libraries are comprised of decades-old Fortran code. Why mess with something that works? Furthermore, the widespread adoption of virtual machines as compilation targets has made it much easier to bootstrap new (e.g. Turing incomplete) languages, while hitting the ground running with access to a full suite of practical libraries to draw on.</p>
<p>Turing incomplete languages can trivially handle anything having to do with conditionals, iterating over collections, trees or performing a transformation repeatedly for a pre-determined number of steps. As such, I believe that a very simple set of constructs can handle anything a common full-stack web developer needs to do for most of their carreer. In the rare edge case one can always expand the range of language primitives or implement escape hatches.</p>
<h3>How to stay total</h3>
<p>It's not too hard to take an imperative or functional language and turn it Turing incomplete. Mainly one just needs to remove unconstrained loops and recursion and replace it with more constrained constructs such as list comprehension, <em>foreach</em> loops, or the <em>map</em>, <em>reduce</em> and <em>filter</em> suite of collection processing functions.</p>
<p>Here's a set of choices that will work for a Turing incomplete imperative programming language:</p>
<ul>
<li>Mutable data structures</li>
<li>No mutable references to first class functions</li>
<li>No unconstrained <em>for</em> or <em>while</em> loops</li>
<li>A modified version of <em>foreach</em> loops, with a cycle checker and a way to iterate through nested data structures / trees</li>
</ul>
<p>If instead you want to make a Turing incomplete functional language you could choose the following:</p>
<ul>
<li>Immutable names and variables, with acyclic data structures</li>
<li>First class functions</li>
<li>No recursion</li>
<li>
<em>map</em>, <em>reduce</em> and <em>filter</em> (with some variants for handling nested data structures and trees)</li>
</ul>
<p>In both cases one would want a system of event listeners to handle user input without needing infinite loops. Any conditionals will work for either scheme, as well as list comprehensions and lazy data structures. Handling more complex loops than iterating over a list requires some beefed up variant of <em>reduce</em>: One could have a <em>reduce</em> operator that gets called for every <em>nested</em> element of a collection, i.e. not just the immediate members of a list, but also their members, if they themselves are collections. For trees it might be handy to support a reduce function with two components: one transformation for descending and one for ascending in the tree.</p>
<p>Guido van Rossum is famously not a fan of <em>reduce</em>:</p>
<blockquote>
<p>[reduce] is actually the one I've always hated most, because, apart from a few examples involving <em>+</em> or <em>*</em>, almost every time I see a <em>reduce()</em> call with a non-trivial function argument, I need to grab pen and paper to diagram what's actually being fed into that function before I understand what the <em>reduce()</em> is supposed to do</p>
</blockquote>
<p>He has a point, but consider the following code:</p>
<div class="code"><pre class="code literal-block"><span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">foo</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">),</span> <span class="n">coll</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
</pre></div>

<p>This is equivalent to / syntactic sugar for:</p>
<div class="code"><pre class="code literal-block"><span class="n">x</span> <span class="o">=</span> <span class="n">val</span>
<span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">coll</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">foo</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</pre></div>

<p>As such it of course makes sense to <em>not</em> use the explicit <em>reduce</em> function througout most Python code and instead use the pretty syntax. Any Turing incomplete language aiming for user friendliness would aim for similarly readable constructs, either via macros or built-ins. Here's an example <em>pythonic</em> nested reduce:</p>
<div class="code"><pre class="code literal-block"><span class="k">def</span> <span class="nf">flatten</span><span class="p">(</span><span class="n">nested_list</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">item</span> <span class="n">nested</span> <span class="ow">in</span> <span class="n">nested_list</span> <span class="k">with</span> <span class="n">result</span> <span class="o">=</span> <span class="p">[]:</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span>
</pre></div>

<h3>Leveraging Turing incompleteness</h3>
<p>Above I have outlined some <em>very simple</em> constructs without fancy type/termination checking, which already can handle the vast majority of retail programmer use cases. This is good news, because once we start down the happy road of tractable language semantics and gain more experience, it stands to reason that even more intricate, efficiency sensitive "capital A algorithms" will be supported.</p>
<p>I have shown that it's not too hard to build a Turing incomplete language. What I haven't yet outlined is how to leverage Turing incompleteness. Partially, this is due to the fact that we don't yet know exactly. This would be a great realm for many different approaches to compete.</p>
<p>We can surmise that Turing incompleteness will help us write more correct software, but doing so will likely necessitate better ways of building specifications against which correctness should be checked. In my very own opinion, expanding on type systems in the <em>ML</em> and <em>Haskell</em> tradition will not be the way to go, or at least not the <em>only</em> way to go.</p>
<p>I'm interested in metalogics that talk about program behavior, which do not follow the <em>intuitionistic</em> type theoretical approach. I.e. I'm interested in specifications with negations. The logic programming literature is full ideas about stratification and the like, in order to make negation a tractable part of a solver, checker or inference system.</p>
<p>Any metalogic or type system can suffer from the aesthetic problem that it increases the surface area of the language and adds more and different syntax to the operational core. In light of this, I have been interested in expressing <em>program metalogic</em> as <em>code patterns</em> and <em>underdetermined traces</em>. But this is a topic of active inquiry, with more to come...</p>
<h3>Back to Gödel: historical remarks</h3>
<p>The above concludes the core of my argument. If you are now wondering "Why, if Turing incompleteness is so promising and accessible, haven't I heard more about it?" let me give you my selective reading of the history of computer science as an attempt at explanation:</p>
<p>Well before computers became a thing, the logicians who invented computer science were more concerned about well-foundedness in mathematics than writing bug-free software. Initially the most widespread definition of "effective procedure" was actually a terminating language: Gödel's seminal incompleteness theorem used a <em>strictly terminating</em> definition of <em>effective procedure</em>: That which we now call <em>primitive recursive functions</em>.</p>
<p>This definition was far from settled though: A convincing <em>negative</em> answer to the <em>Entscheidungsproblem</em> (whether there is an <em>effective procedure</em> to prove or disprove any mathematical statement) required a satisfying definition of "effective procedure" beyond all doubt, one for which the scientific community could agree that there was no "larger" sensible definition of "algorithm" in which the <em>Entscheidungsproblem</em> could happen to be true <em>after all</em>. Following considerable scientific debate, the <em>general recursive functions</em> as well as Turing machines and the lambda-calculus were accepted as equivalent, encompassing conceptions of <em>effective procedures</em>.</p>
<p>The choice of Turing machines as definition was not based on <em>user-friendliness</em> or manageability, rather it was chosen to be <em>maximal</em>, so as to eliminate all doubt with regards to an uncomfortable negative result. Particularly, making no claims about whether the <em>difference</em> between Turing machines and the terminating languages (such as the primitive recursive functions or <em>Gödel's System T</em>) contained any valuable or sensible algorithms.</p>
<p>Turing machines perhaps might have been relegated to a position of less prominence, relative to other (including total) formalisms in the lambda-calculus family, if early computers had not come about so swiftly and the <em>von Neuman architecture</em> hadn't so closely resembled a Turing machine. The comparison is apt: Computer memory functions as (unfortunately finite) read-write tape, while registers roughly correspond to machine state and the CPU to the transition function.</p>
<p>Programming in binary and assembly obviously mirrored the von Neuman architecture in Turing completeness. Languages with abstract control structures soon followed. These <em>programming languages</em> roughly fell into two camps: those with loops (<em>Fortran, COBOL, BASIC, C</em>) and those using recursion for code repetition (<em>Lisp, ML</em>). Unfortunately, both approaches, in their chosen form, also entailed Turing completeness. </p>
<p>Why did the earliest programming languages all default to being Turing complete?</p>
<ul>
<li>Turing completeness (accidental or not) is so easy to achieve that without focus on the matter it becomes inevitable in programming language design.</li>
<li>The Turing machine had a head start as predominant paradigm for computation. Lambda calculi were hard to implement (for lack of complex data structures) and underdeveloped: The <em>simply typed lambda calculus</em> was <em>too</em> simple for real computation and <em>Gödel's System T</em> was not published before 1958 -- the same year that <em>Lisp</em> was invented.</li>
<li>For lack of meta-reasoning capabilities, complex type systems, abstract data structures and processing power, the early programming languages were unable to take advantage of the benefits of Turing incompleteness.</li>
<li>Infinite loops are an attractive concept for managing system-level tasks.</li>
</ul>
<p>By the time calculi like <em>System F</em> were developed, the paradigm of arbitrary recursion had become so entrenched that almost by default Haskell became Turing complete, even though its type system is ostensibly based on <em>F</em>. Turing completeness has become synonymous with computing, whereas virtually no software in use requires the full arsenal of Turing completeness.</p>
<p>We largely owe this state of affairs to the popularity of arbitrary loops and unrestrained recursion. Nevertheless there is hope of escape: Turing incomplete constructs such as <em>list comprehension</em>, <em>foreach</em>-style iteration (together with lazy data structures and generators) and functions in the family of <em>map</em>, <em>reduce</em> and <em>filter</em> are gaining popularity and actually considered the more idiomatic means of writing repetitions in many popular programming languages such as <em>Python</em> and <em>JavaScript</em>.</p>
<p>We find ourselves in a situation where those who know about Turing incomplete languages are mostly academiccs who think that "computing" is about "capital A algorithms" (which are harder to represent efficiently). The hordes of software engineers in industry who know that most programs are really rather simple, think that Turing completeness is computing <em>per se</em>. I see an oportunity here. </p>
<h3>So, what are you waiting for? Let's start terminating!</h3>
    </section><footer class="post-footer"><span>

              

        </span>
    </footer></article><article class="li post"><header class="post-header"><h3 class="post-title"><a href="posts/im-not-a-tinkerer-the-painful-hardly-instructive-story-of-how-i-became-a-decent-engineer/">I'm not a tinkerer: The painful, hardly instructive story of how I became a decent engineer</a></h3>
        <p class="post-time"><time datetime="2020-08-19T14:54:57-05:00">2020-08-19 14:54</time>
        by
                Gabriel Pickard
        </p>
    </header><section class="post-excerpt"><h3>The RPG from Hell</h3>
<p>Role-playing games seem to have an obsession with underground lairs full of monsters. (<em>Dungeons &amp; Dragons</em> even has it in the name.)
As a kid, I remember watching my brother playing <em>Diablo II</em> on his PC. Everything was droopy, gloomy, scary and dark. -- And that was just at the surface level! Then he descended into one of the dungeons, where the real action was! <em>It was oppressively horrifying to my childish soul.</em> There I sat with my eyes glazed over, my clammy little hands clenching the sides of my deeply unfashionable corduroy thrift store pants, transfixed yet wondering: Why would anyone want to go down there into those dungeons? There's nothing there! Only monsters! Why not just stay at the surface? Maybe hide, maybe get the Dark Lord's phone number and broker a deal from the safety of the village? How would that sound?</p>
<p>This is how I generally have felt when approaching a new piece of technology. Transfixed, but wondering how many dead-ends, unsolvable problems and wasted hours await me. I'd <em>much</em> rather spend time at the surface, learning about the theory, capability and higher-minded concepts. I <em>do not</em>, as a rule, favor getting my hands dirty.</p>
<p>In other words: I am not a tinkerer.</p>
<p>For this I have long considered myself at a serious disadvantage compared to many of my software engineering colleagues. A disadvantage only to be made up by technological brilliance. A brilliance so epic, that... I surely must falter at implementing it. This is the tragedy of my professional life, of which I have come to sing:</p>
<h3>I don't do computers</h3>
<p>I grew up a bookish kid, by all accounts destined for the humanities. My first and only failing grade in middle school was a remedial computer class. I didn't play with Lego Technic. It had never occured to me that anyone would care to take the washing machine apart, just to find out how it works. When my best friend did just that and got into hefty trouble, I was astonished and admired him greatly for it, but was under no illusion that such a path was for me.</p>
<p>But there was something that drew me towards computing machines, despite all the odds: Ever since I picked a losing fight with the boss kid in kindergarten and found myself no longer welcome to the sandbox, I have been interested in power; How it works, who has it and how it may be gained. When I say "interested", of course I mean <em>academically interested</em>. Let's just say that a lot of my social experiences in childhood were of the, <em>ahem</em>, "outside-looking-in"-variety, if you catch my drift. Socially shunned and ill-adept, what's a greasy-haired kid to do? -- My answer, like many a kid, was to make my thoughts my own best friends.
The world with all its physical objects was too scary and frankly just too heavy for my scrawny arms. But not in my fantasy, there I happened to be in the deadlifting business.</p>
<p>Enter computers: Again, <em>computer games</em> remained the domain of more adept individuals than me. Reflexes, practical mastery? Not my cup'a tea. Most games were also just too damn scary for my gentle soul. No, I had to stick to something less fast paced if I was going to keep up.
It was the concept of programming that intrigued me: Here is a device that could bring thoughts to life! Concepts from my mind finding embodiment -- what a heady idea! At last I would find myself <em>in power</em> in a domain where I actually felt at home. It didn't hurt that society was talking about tech as the way of the future. -- Furthermore, who knows -- <em>I might even manage to talk to girls?</em> (A popular non-sequitur if there ever was one!)</p>
<p>So, as an angsty teen around the turn of the century -- with my remedial computing knowledge -- I set out to build an <em>operating system for AI</em>. I invented an xml-based "declarative" "programming"-"language" which I compiled to x86 assembly using a healthy pile of regular expressions in a sauce of Perl. Don't go looking for my usenet posts from back then. Please. Not much came of my youthful software ambitions, though I did learn a thing or two about Perl and Java along the way.</p>
<p>More impactful, surprising, and in a completely unrelated chain of events, I started talking to girls, which largely involved a few brave (or severely congested) souls willing to <em>smell past</em> the pronounced <em>body odor problem</em> I was nursing at the time.</p>
<h3>Math for Rubes</h3>
<p>I enrolled in Cognitive Science as an undergrad, hoping to do something between Philosophy and Computer Science, without perishing of the stuffiness of either. Little did I know that I was going to discover a pearl that had long been hidden from me: The joy of Mathematics and Logic.</p>
<p>As a child, I had viewed Math with the same disdain, fear and shame as I would a Rubik's cube: An inscrutable jumble, promising nothing but joylessly toil and failure. <em>Rubik's cubes were not a part of my world.</em></p>
<p>But now I learned that I didn't really need to be a tinkerer to do Math. I just needed to be a committed thinker! It was a realm of thought, with logic as a worthy opponent. What a joy it is to say: <em>What I want to do is impossible, logic does not support it. However, what I want to do is reasonable, what can I do instead? Perhaps I can bend my requirements, change my perspective to express that which I want to formalize it in such a way that logic will accept it nevertheless, if begrudgingly.</em></p>
<p>My advice for improving STEM participation: teach Math as the formally rigorous branch of the humanities that it is!</p>
<h3>Machine Learning doesn't work yet</h3>
<p>Next to Logic, in my studies I soaked up statistical NLP, Good Old Fashioned AI as well as Neural Nets. This was back in the day when Support Vector Machines were <em>de rigueur</em>. But there were some whispers around the edges about so-called "Deep Belief Networks".</p>
<p>The year was 2007 and I was going to build generative language models using auto-encoders. Only problem: Deep back-propagation didn't really work yet -- and you had to build it yourself, so if it didn't yield results you were never quite sure whether it was a bug or shortcomings of your algorithm that was thwarting you. I, for one, had a lot of bugs.</p>
<p>I failed at generative natural language models, proceeded to (re-)invent adversarial networks, but failed to use the new training algorithms that were pouring out of <a href="https://en.wikipedia.org/wiki/Geoffrey_Hinton">Geoffrey Hinton's</a> lab and instead (in a stroke of self-defeating genius) decided to roll my own Evolutionary Algorithm. None of my supervisors thought it worth publishing by the time I managed to limp across the graduation line.
Frustrated, I concluded that there wasn't much future for me in academia, and picked up web development.</p>
<h3>Engineering is an anti-pattern</h3>
<p>Remember, I was a Cognitive Science major. While I could nail together scripts, I didn't really know how to write software! But, the myth of Silicon Valley was wafting through the air and it drew me in, much like our dog will pull at her leash if she smells a pee-stain across the street.</p>
<p><strong>I was going to build an app and it would be successful. -- What if I built a unified messenger app? That's something I don't know much about!</strong></p>
<p>Unfortunately around the same time, health issues were taking over. I had been in chronic pain for a while and with limited attention span I had skated through college and grad school mostly soaking up information osmotically from lectures and classmates. Sitting down and reading a technical book was quite the undertaking. Sitting down and writing -- nay debugging half-understood code was the ultimate nasty, dark and gloomy dungeon to descend into. And yet I tried.</p>
<p>Debugging is a curious beast. As coders <em>we will</em> run into situations where we don't know how to even start at least once in a while. Problems and bugs where we have <em>no clue</em>. As a neophyte we will run into them all the time. What it takes to deal with those situations is incredible steadfastness, willingness to try many things and a breadth of experience.</p>
<p>People with a predisposition to start small, prod, experiment and generally muck around at are a distinct advantage. They get into less inscrutable dead ends, gain a breadth of experience much more quickly and generally build stuff that <em>actually works</em> instead of stuff that <em>sounds like a good idea</em>. Through my bleary eyes, staring at the editor, it dawned on me: If I wanted to make it in software, I had to learn to imitate those kinds of people: tinkerers.</p>
<h3>The consummate tech CEO</h3>
<p>One must imagine <a href="https://en.wikipedia.org/wiki/The_Myth_of_Sisyphus">Sisyphus</a> as an ancient Greek Elon Musk.
Really -- have a look at the Wikipedia page: The similarity is striking. Sisyphus was a busy-body. Before his punishment, he was running around Hellas, out-innovating mortality, squeezing the Olympian shorts placed on him by Zeus, generally being hyper-active and full of himself. <em>The craftiest of men.</em> Vapid yet gargantuan projects such as Mars colonies, saving our wasteful car-driving lifestyle in the face of reality or rolling rocks up a hill are truly a just form of punishment for <em>that kind of guy</em>.</p>
<p><em>I was not that kind of guy</em>. I was a tech wannabe. I would work on ambitious projects: Unified messaging, or a document database with indexing based on <a href="https://en.wikipedia.org/wiki/Anti-unification_(computer_science)">anti-unification</a>, or a reddit clone where subreddits were replaced by embeddings into a non-euclidean space. That kind of stuff. Unlike those Muskian achievers I didn't make it big. I actually didn't really make anything that people actually got to see and use. <em>Much like</em> Sisyphus' punishment the stone of my attention would always slip -- before I had a chance to ship.</p>
<p>There's no way to sugar-coat it: I fundamentally confused writing software with yak shaving. I would push myself deeper and deeper into theory and prescient optimizations, until the project just kind of became inert... sat there a while... and then I slowly, slowly, imperceptibly <em>gave up on it</em>.</p>
<p>How amazing is it that for his punishment by the Gods, Sisyphus basically gets turned into a <em>me</em>!
Before, he's achieving, he's meeting deadlines, he's outrunning the greatest deadline of all: Death itself. Afterwards, he's striving, striving, striving... But without results.</p>
<p>It is the moment of failure in this myth that truly intrigues me. That instant where the rock slips out of his hand and rolls back down. Surely, he must get it, right? <em>But no</em>, he doesn't get it. The <em>slip</em> is but an afterthought, an unsolved riddle to be glossed over. The Sisyphus solution is: <em>try harder.</em></p>
<p>I, for one, have tried <em>trying harder</em>. To build a successful product. And I've failed at it.</p>
<p>But <em>en passant</em> to rolling up my own hill of technological hubris, I actually did learn enough jargon to pass tech interviews.</p>
<h3>FizzBoss</h3>
<p>You know how interviewers used to use fizzbuzz to weed out people who couldn't write code? Lucky for me I did know how to solve fizzbuzz. I actually knew more than that: I was able to talk intelligently enough about advanced technical topics. All those fancy technologies I had been fantasizing about. Problem was: I couldn't for the life of me get a simple software project across the finish line.</p>
<p>Indeed, I was a 0.1x programmer trapped in the body of a conversant technologist. Suffice it to say: I had trouble holding down a job. But I could pass interviews, so I could get a new one. Bit by bit things changed; I learned to stick it out. I was blessed to meet some of the kindest people in tech who endured me and my meandering incompetence. If there's any moral in this sordid tale: Talking can help and hiding can hurt.</p>
<p>We do not actually live in a world of mythical punishment. Simply by showing up and failing, after a while, I somehow acquired enough practical knowledge to actually do my job. In a mysterious way, many important things happen while we're not paying attention. Sometimes, all it takes is the follow-through to keep doing it. Which is really the benefit that tinkerers have: They'll just keep on playing around with something and gain experience while doing so.</p>
<p>My difficulty is that I will be scared and I will freeze and shrink away from taking action and gaining hands-on experience with the code beast. So now, if I'm trying to learn something expansive and complex, I often choose to first work on stuff that's related, yet non-threatening. It's a true art-form to find preparatory projects that don't feel like homework. I want to be concerned with the deep and conceptual, not the fiddly work! But finding just the right on-ramp for my proclivities and capabilities can be an analytical task! And if there's one thing I can do, it's analytical tasks.</p>
<p>My mind will always tend towards analyzing and conceptualizing over acting and manipulating. So I have developed tricks to transform activity-heavy work into a sequence of analysis interspersed with non-threatening manipulations. </p>
<h3>A warm and fuzzy codebase</h3>
<p>It all came back to that fear of dungeons. Familiarity dissolves the fear. When I was watching my brother playing <em>Diablo</em>, he wasn't overwhelmed by fear; He may have had some spooky excitement, but mainly he was enjoying a feeling of mastery and accomplishment, on the basis of a certain sense of safety -- of <em>knowing how the game works</em>.</p>
<p>Nowadays, I sometimes can even enjoy tinkering around a little. I still find it hard to focus if I can't relate my task at hand to some larger concept. One key factor in this professional growth has been to respect my own brain and its peculiar workings. If I sit myself down with nothing but a vague notion of what it is I'm about to do -- and expect to achieve results, then I'm setting myself up for failure. </p>
<p>I have had to learn to:
1. <em>Not do Engineering</em> -- As best I can to avoid the compulsion to come up with "the right solution" and dwell on the conceptual.
2. Manage my fear of finding out how the machine actually works -- familiarity breeds contempt, and contempt is what you want when setting out to slay dragons.
3. Work with the kind of person that I am: I cannot simply sit down at a keyboard and write code freeform. I need a rough and realistic plan for what I'm going to do algorithmically.
4. Know what to punch into Google when there's a problem.</p>
<p>I have come to taste the joy of doing manageable tasks in a code-base that I know like the back of my hand. Sometimes my requirements still turn out too steep, concepts too abstract, implementations too tricky. It remains a struggle not to drop the rock.</p>
<p>But that's how I roll.</p>
    </section><footer class="post-footer"><span>

              

        </span>
    </footer></article><article class="li post"><header class="post-header"><h3 class="post-title"><a href="posts/how-video-conferencing-fails-the-cocktail-party-effect/">How video conferencing fails the cocktail party effect</a></h3>
        <p class="post-time"><time datetime="2020-04-28T17:06:58-05:00">2020-04-28 17:06</time>
        by
                Gabriel Pickard
        </p>
    </header><section class="post-excerpt"><p>I've been attending a lot of video conferences lately. Some of them meet the definition of a <em>meeting</em>: 3-20 people in a room, with one person speaking while everyone else listens. This is a well-understood UX paradigm, decently served by the likes of Zoom, Google Hangouts and Jitsi and originated in the business world as a natural corollary to conference calls over the telephone.</p>
<h3>Zoom parties are pathetic</h3>
<p>A lot of my recent video calls do not <strong>at all</strong> fit into the <em>video-conferencing</em> paradigm: They are virtual social gatherings, intended to fulfill the need for community, human connection and fun in times of social distancing. Most of them should not meet the basic criterion of a meeting: There's no agenda. Usually there's more than one topic and more than one person wanting to speak at any given time. These get-togethers are shoe-horned into a User Experience that has very little to do with their intended reality: a loose, multi-stranded interaction.  In normal social gatherings, even if it's just four or five people, there is a natural ebb-and-flow from joint conversation to breaking off to talk about something in private, or even overhearing a word and joining back in (the famed <a href="https://en.wikipedia.org/wiki/Cocktail_party_effect">cocktail party effect</a>).</p>
<p>The <em>cocktail party effect</em> is related to a basic human need: Ambient social awareness, which makes social gatherings interesting, fulfilling and comforting. We want to know who is talking to whom. <strong>But</strong>, we don't want to be <em>forced to listen</em> to every word they say. In video calls it's so easy to get impatient, waiting for a turn to get a word in edgewise. While I love my friends, they can be tedious at times. This is exacerbated by the fact that most video conferencing apps practice active noise-suppression: They are specifically targeted at letting only one source speak at any given time. </p>
<p>There have been some <a href="https://tedcooke.blog/2020/04/13/21-things-we-learned-from-hosting-our-first-online-party/">great</a> <a href="https://www.houseparty.com/">attempts</a> at enabling multiple parallel conversations, using <em>breakout-rooms</em>: sub-sessions of a conference call, which can be easily reachable from the main context. However, the hard break between main and breakout room still remains.</p>
<p>On the internet, software shapes social interaction. This is nothing new, in the real world we shape our social interactions all the time. There are clear differences between the kinds of connections you can have in a noisy dive bar, an office break room, at home in your living room, on a factory floor, or while out together on a forest hike. As developers of social apps we should be able to formulate clearly what kind of social interaction we are looking to shape. Is it productive? Confrontational? In-depth or fleeting? Warm or impersonal?</p>
<p>Zoom calls shape a kind of social connection that may be effective for jointly pursuing a work-related agenda. But it falls flat when trying to, you know, <em>actually connect</em>. We also should not kid ourselves into believing that social needs are purely a matter of private life. If we are to make remote work viable at scale, we have to take them into account.</p>
<h3>Criteria for a good social gathering app</h3>
<p>In short, we want:</p>
<ul>
<li>Multiple adjacent conversations,</li>
<li>aware of each other's participants and content,</li>
<li>without interfering with each other.</li>
</ul>
<p>Additionally we may also appreciate:</p>
<ul>
<li>a shared context or world to inhabit, things to look at or manipulate together.</li>
<li>the ability to pass by, casually join or leave a conversation: in-between-states.</li>
</ul>
<p>The most natural realm in which these sorts of casual/world-driven dynamics have played out online are multiplayer games. For many individuals and some social groups, games have been a great way to spend time together: It's not by accident that games such as <a href="https://www.animal-crossing.com/">Animal Crossing</a> have been a hit in the recent COVID-months. But even the best of games will always be attractive to some, but boring to others, even amongst people who "like games" there will be a variety of opinions about which game to choose. So if you want to have a <em>social</em> gathering, focused on the social interaction rather than on the world it's embedded in, you may want to turn elsewhere.</p>
<h3>Spatial social software</h3>
<p>One compelling idea has been to embed people as avatars in a simple virtual 2D or 3D space, using text, audio and/or video communication. (See: <a href="https://darkblueheaven.com/spatialsoftware/">Spatial Software</a>, <a href="https://extendedmind.io/blog/2020/3/20/video-conferencing-wont-cure-loneliness-avatar-chat-apps-can-help">Avatar chat apps</a>, <a href="https://techcrunch.com/2020/04/18/clubhouse-app-chat-rooms/">Spontaneous social apps</a>) The watch-word here is <em>simple</em>: most recent approaches have eschewed going full-bore 2nd life -- instead they  offer more abstract UX primitives, such as an abstract 2D space, in an attempt to sufficiently model some selection of the criteria for a <em>good social gathering app</em> I put forth above.</p>
<p>"Conversation adjacency" in these apps is organized in three rough categories:</p>
<ul>
<li>a list or tree of individual rooms</li>
<li>two-dimensional spatial embedding</li>
<li>three-dimensional embedding</li>
</ul>
<h3>VEEPARTY</h3>
<p>Many of these realtime-social apps look really fun and interesting, but most have <em>either</em> a spatial context (with artificial avatars)() <em>or</em> video chat. Ultimately I actually want to see <em>and</em> hear my friends in an explorable setting.
Under normal circumstances my gripes with video conferencing would have lain fallow as I wait for someone else to fix it, but as fate willed it I had some time on my hands and was stuck at home. -- So I put together a webrtc app to play around with the above requirements list: <a href="https://veeparty.horse">https://veeparty.horse</a></p>
<p>Veeparty is a video chat app embedded in a zoomable 2D space. </p>
<ul>
<li>Users are represented by a circular video avatar that they can move around freely.</li>
<li>Every user has a defined "earshot radius" in which they can hear others.</li>
<li>Other participants beyond that radius can not be heard, but you can see a real-time transcription of what they are saying at a glance (hence approximating the cocktail party effect).</li>
<li>Users can draw and write on the background and embed images, making the space their own and having fun.</li>
<li>You can create a new space for you and your friends or join an existing public space.</li>
</ul>
<p><a href="https://theonline.town">Online Town</a> is a closely related app. It has a simple interface, embedded in a 2D space, people are able to move around and there is a notion of distance and radius-of-hearing. I do have number of differences of opinion when it comes to User Experience, but I invite you to form your own opinion!</p>
<h2>Zoom meets Minecraft</h2>
<p>In playing around with veeparty, I've had the growing sense that there's maybe an interesting new category of app here: Something that's decidedly not a game, but nevertheless integrates many playful / world building aspects. An app that you might even play games inside of but that fundamentally is just a simple world for people to meet in and interact.
In a way this hearkens back to the early era of facebook apps (and perhaps there are a number of lessons to be learned from that cautionary tale).</p>
<p>For now the plan is to keep adding simple primitives for fun interactions between friends or strangers. My app is still very rough around the edges and only supported on Desktop Firefox and Chrome, so <a href="https://veeparty.horse">check it out</a> with that in mind.</p>
    </section><footer class="post-footer"><span>

              

        </span>
    </footer></article><article class="li post"><header class="post-header"><h3 class="post-title"><a href="posts/how-bad-will-it-be-economic-and-political-effects-of-covid19/">How bad will it be? Economic and political effects of COVID19</a></h3>
        <p class="post-time"><time datetime="2020-03-20T12:43:18-05:00">2020-03-20 12:43</time>
        by
                Gabriel Pickard
        </p>
    </header><section class="post-excerpt"><p>So you're entering lockdown mode and now you have two questions: How long will this last? And how bad will this be for the economy? Here I provide my answer to the second question: <em>the economic and political effects of the pandemic</em>. In <a href="posts/covid19-lockdown-how-long-will-it-take-and-how-will-it-change-us">the first part of this series</a> I give an estimate of how long it will take and what it will be like for us to live through this grand experiment.</p>
<p><em>After months of underestimating COVID19, the pendulum is finally swinging the other way. People are worried! But we need to remain calm. Mitigating this disease will indeed be very costly, but we are not looking at a bottomless pit, both in terms of time and money. This will not be the end of civilization.</em></p>
<p><img alt="plague doctors" src="images/plague_bigger.gif"></p>
<h3>Politics</h3>
<p>Donald Trump's hold on power will likely strengthen with COVID19. If it hadn't been for the administration's recent about-face (<a href="https://www.vanityfair.com/news/2020/03/tucker-carlson-on-how-he-brought-coronavirus-message-to-mar-a-lago">thanks Tucker</a>), Trump would be doomed. But now, the federal government is responding to the recession in an unprecedented manner, including direct payments to consumers, with the Republican party overtaking mainstream Democrats on the left (economically). I am surprised at the speed with which political orthodoxy is changing and yet again Donald Trump stands a chance to escape the clutches of his own idiocy which was on display with his initial <em>"it's just a flu"</em> denialism and criminal suppression of testing.</p>
<p>As it stands, a COVID-recession alone will not keep Trump from re-gaining the White House in November. Even if the economy were to slide even deeper, the presumptive Democratic nominee Joe Biden is poorly suited to beat him. The Democrats have been becoming the party of affluent suburbanites and may irrevocably be forsaking the working class.</p>
<p>If this trend continues and Trump keeps overtaking Democrats on the left, the rising left-populist movement currently associated with the Sanders campaign will be looking for a new home. There will be attempts at starting / joining a third party. We may also see socially left-wing, <em>even socialist</em> candidates popping up in Republican primaries!</p>
<p>China will rise. The People's Republic will benefit from being less affected than everyone else. China already is the largest industrial power in the world. As economies around the globe will grind to a halt, China will play a similar role as the US did in the world wars: A well-industrialized and less-affected hinterland. Jack Ma got China serious good PR for his donations and China looks very competent in comparison to the west.</p>
<p>Those Chinese exporters that have survived, though badly hurt, will now face captive markets: locked-down economies abroad will first need medical supplies, but later demand for all sorts of goods should take off, because of domestic factory shutdowns.</p>
<p>The Trump adminstration is trying to gin up anger between reactionaries and woke people by branding COVID19 as the "Chinese Virus". This is classic divide-and-conquer strategy: It distracts the Trump base from <em>his failure</em> to acknowledge the threat in time, which will needlessly kill hundreds of thousands of his very own constituents, while costing the economy dearly (compared to milder measures which would have been possible).</p>
<p>This squabble over naming also coopts the legitimate movement to repatriate manufacturing to the US, in a way which alienates the Chinese. Framing the rise of China as a world power in antagonistic terms is a dangerous game, which will likely end very badly for the United States. Instead we should follow the model pioneered by the British Empire: In its decline, the Empire closely aligned with one rising power (the US) against another rising power (Germany).</p>
<p>At this point the United States has managed to antagonize and unite most rising powers (Russia, China, Iran) against it. If Tulsi Gabbard ever became president (there's some chance she might end up being Biden's VP), we might see an effective alignment with India. This might make sense if Prime Minister Modi's party weren't so fascist.</p>
<p>The European Union is ripping apart. Countries at the periphery of the Eurozone, such as Spain and Greece have been savaged by austerity and never recovered from the 2008 financial crisis. They will fall off a cliff unless the center, lead by Germany takes <em>extremely radical action</em>, even then, the odds don't look good.</p>
<h3>Economy</h3>
<p><em>Like a shark, capitalism needs to <a href="https://en.wikipedia.org/wiki/Shark#Sleep">keep moving</a> in order to survive.</em></p>
<p>This received wisdom will be put to the test in the next few months. The danger scenario is the following: In a lockdown consumers stop patronizing businesses, which in turn go bankrupt, default on their loans and lay off staff. As people come out of lockdown they find themselves out of a job. Banks are unable to provide loans to start new businesses because their balance sheets are under water due to all the bankruptcies. The situation looks dire.</p>
<p>In reality, things are slightly less bleak: The government is able to step in and freeze loan and rent payments, it can dump money on banks, businesses and consumers directly, in order to keep all the economic players in place, without severing employment and customer ties. This would be the equivalent of holding a shark in place while pushing water through its gills with a hose. Then, as soon as the lockdown is over, everyone in the economy can go back to business as usual, with their job, their business, their suppliers and customers still in place. I.e. the shark can just start swimming again... <em>Or can it?</em></p>
<p>Perhaps the biggest, least-discussed problem in the US economy is <strong>at-will employment</strong>. In most states companies can fire their employees at any time, without reason. This is fantastically harmful to the economic scenario we are facing right now. People are getting laid off in droves. So, when the economy reawakens, there will be no true resuscitation because of demand destruction: Unemployed people can't afford to buy stuff, pay rent, mortgages etc. so the businesses that served them go bankrupt, banks underwater, more people get laid off, everyone suffers -- the economy enters a downhill spiral.</p>
<p>This downhill spiral usually continues until business, consumer and finance expectations shift from "more decline" to "growth" and they start buying, investing, lending and hiring again.Often this change in expectation comes due to a catalyzing event, like a government stimulus package. The economics of a pandemic actually have such an event built-in: once lockdowns are lifted, we can expect at least some pent-up demand to hit the markets: things that people had wanted to buy and put off until after, <a href="https://www.reuters.com/article/us-health-coronavirus-china-retail-idUSKBN21447W">restaurant meals</a>, visits to the relatives, (plus all the travel they had to cancel but still have flight credits for), nights out and going to the movies etc. Of course all of these activities would still be constrained, however we should expect significant growth compared to the in-lockdown economy.</p>
<p>Post-lockdown pent-up consumer demand could be quite potent if paired with payments directly from the government to consumers. Furthermore, during the commercial shutdown, some stocks of manufactured goods will have been depleted, so as businesses come back online they may have to hire additional people in manufacturing and logistics to meet demand.</p>
<p>We can expect a modicum of economic recovery in the middle of this year, following the institution of a reopen-and-test regime. But it may end up being weak and short: There are a number of factors beyond infectious disease that would indicate a continuing recession. International trade will still be disrupted and recovery disjointed, oil and natural gas markets will have cratered, popping the fracking bubble going on in the United States. There are bound to be bad loans made within the "easy money regime" of the last decade, which now will sit on balance sheets and could inhibit investment. (What remains to be seen is whether we can get out of this with more easy money.)</p>
<p>One thing seems likely: Governments will <em>spend</em>. It's what saved them last time (2008) and they will try it again. To the extent that this spending will finally go into the pockets of ordinary people (not just the banks), expect a rise of inflation. Current generations of bureaucrats do not have experience with an inflationary economy, mistakes will likely be made.</p>
<p><a href="https://www.nytimes.com/2020/02/28/us/politics/trump-coronavirus.html">We may see</a> some countries transition to a kind of (temporary) command economy, as governments step in, perhaps (partially) nationalizing key industries. This is a good move, since it allows the government to keep people on the payroll. After the clear failure of austerity following 2008, the pretense of free-market liberalism is finally crumbling.</p>
<p>Historically speaking, the economic effects of pandemics have been surprisingly mild (cf. <a href="https://www.stlouisfed.org/~/media/files/pdfs/community-development/research-reports/pandemic_flu_report.pdf?la=en">Spanish flu</a>, <a href="https://en.wikipedia.org/wiki/Consequences_of_the_Black_Death">Black death</a>). Shrinking the workforce leads to better conditions for workers and more resources available to survivors. However, we cannot simply apply this to our situation:</p>
<ul>
<li>We are unwilling to just let people die.</li>
<li>With modern medical technology we can combat the disease. This is costly.</li>
<li>We have a strong enough state and willingness to institute curfew measures. It stops the virus, but costs the economy.</li>
<li>Our economy is based on markets instead of farming -- we are more complex and more fragile. Lockdowns and quarantine (which are not new) hurt us more than in the past.</li>
<li>Our current market society is global and excessively connected. We spread diseases much, much faster than we used to. Instead of rolling local crises, we have crisis almost everywhere concurrently.</li>
</ul>
<p>Nevertheless, there is hope. Our current recession is driven by an external factor which is manageable. Controlling the virus will not be easy, however the mitigation program itself can provide jobs and some economic stimulus. </p>
<p>Ultimately the disease will fade into the background. In the mean time we have a ramshackle plan to prop up our economy with massive infusions of cash. Luckily the last financial crisis put <a href="https://en.wikipedia.org/wiki/Keynesian_economics">Keynesian Economics</a> back onto the map. (Otherwise we would not survive this.) We have a decent chance of getting out of this pandemic with just a "<em>normal</em>" recession. <strong>Not a depression</strong> death spiral. But getting there will take <em>extraordinary political will to completely restructure the economy if necessary.</em></p>
<p>If however the European Union (or some other world power) collapses economically, the US will likely get pulled back down, possibly into depression as well, in the later half of 2020 or next year.</p>
<p>Even when the economy as a whole comes back eventually, <em>you or people you care for</em> may be very badly hurt in the mean time, because the shutdown is so harsh and mitigation measures so crude. The only way out is to <strong>self-organize in solidarity</strong>. Many people are <em>eager, eager</em> to help, if we ask for help. I will go out and help as many people around me as I can. I happen to have a little prepper supply of pandemic essentials. Particularly the old and the homeless and the lonely will need it. Even just talking to someone at a safe distance can be a good thing. I hope you'll join in helping if you can!</p>
<h3>Environment</h3>
<p>COVID19 is perhaps the best thing to <a href="https://www.dw.com/en/coronavirus-climate-change-pollution-environment-china-covid19-crisis/a-52647140">happen</a> to our climate within the last 100 years.</p>
    </section><footer class="post-footer"><span>

              

        </span>
    </footer></article><article class="li post"><header class="post-header"><h3 class="post-title"><a href="posts/covid19-lockdown-how-long-will-it-take-and-how-will-it-change-us/">COVID19 lockdown: How long will it take and how will it change us?</a></h3>
        <p class="post-time"><time datetime="2020-03-20T12:30:10-05:00">2020-03-20 12:30</time>
        by
                Gabriel Pickard
        </p>
    </header><section class="post-excerpt"><p>So you're entering lockdown mode and now you have two questions: How long will this last? And how bad will this be for the economy? Here I will give my answer to the first question: <em>how long it will take</em>. <a href="posts/how-bad-will-it-be-economic-and-political-effects-of-covid19">The second part of this series</a> deals with the political and economic ramifications of the pandemic.</p>
<p><em>After months of underestimating COVID19, the pendulum is finally swinging the other way. People are very worried! But we need to remain calm. Mitigating this disease will indeed be very costly, but we are not looking at a bottomless pit, both in terms of time and money. This will not be the end of civilization.</em></p>
<p><img alt="plague doctors" src="images/plague_bigger.gif"></p>
<h3>How long will it last?</h3>
<p>The good news is: With a focused and capable public health response, lockdown <em>does not</em> have to last forever. <em>It can be a matter of just a few months</em>. The bad news is that we have to really get our act together: We need a competent administration.</p>
<p><em>(In the following I will use the term "lockdown" imprecisely for any significant measures to make people to stay at home. Eskimos <a href="https://en.wikipedia.org/wiki/Eskimo_words_for_snow">may or may not</a> have many words for snow, but we haven't yet developed a popular vocabulary for pandemic mitigation efforts.)</em></p>
<p>A lockdown for COVID19 needs to be strict and take <em>at the very least</em> 3 weeks. That is about the time required for the disease to run its course. This prevents people with mild or no symptoms from moving in society and infecting others. Once the number of new cases slows and starts dropping the main determining question becomes: <em>How long does it take to set up an effective task-force to run post-lockdown control measures?</em></p>
<p>We should not go ahead with reopening until we have supplies and staff for ubiquitous testing and contact tracing in place (as well as replenished hospitals). I presume we would simply copy the <a href="https://www.youtube.com/watch?v=zu8C2MXrhvA">Chinese mitigation model</a> -- though the US does have a penchant for <a href="https://www.politico.com/news/2020/03/06/coronavirus-testing-failure-123166">"roll your own"</a>.</p>
<p>The approach taken in China (and several other countries) involves tracking people's movements, taking their temperature at the entrance to every gathering place and setting up quick serve fever clinics for SARS-CoV-2 testing. If someone tests positive, staff tracks down and test all their recent contacts.</p>
<p>In theory such a mitigation strategy would work, though currently there isn't much indication of a focused effort to prepare for post-lockdown in the US. Our health system is still mainly struggling to keep us from entering a world of death panels and mass graves.</p>
<p>Even when we get past that stage, mitigation is no joke. There can be <a href="https://www.wsj.com/articles/singapore-taiwan-and-hong-kong-face-second-wave-of-coronavirus-cases-11584445836">second wave outbreaks</a>, which is why a half-assed response won't cut it.
Americans will have to adapt to constant controls. Will we need to track people's movements? I hate the privacy implications, but I also hate infectious diseases killing our grandparents.</p>
<p>Americans need to finally start wearing masks. <a href="https://www.businessinsider.com/wuhan-coronavirus-face-masks-not-entirely-effective-2020-1?op=1">This</a> <a href="https://time.com/5774521/coronavirus-face-mask-prevention/">kind</a> of <a href="https://www.forbes.com/sites/tarahaelle/2020/02/29/no-you-do-not-need-face-masks-for-coronavirus-they-might-increase-your-infection-risk/#1440d4bb676c">disinformation</a> to discourage mask usage is disingenuous and harmful. Currently the US has a shortage of masks, which indeed are very useful and are needed by medical professionals. Instead of admitting to poor planning and rationing masks, we are being misled. While it is true that masks do not perfectly protect you against getting infected, if everyone wears a mask, <em>those who are infected are much less likely to pass it on</em> to others.</p>
<p>The Chinese administration loosened their lockdown after about <strong>two months</strong> -- I expect the US to take about as long, possibly a bit longer. Our administration has the advantage of more information about the illness, but likely a less efficient apparatus. -- It may well happen that we open things up and then have to close them down again in some places, due to insufficient control measures.</p>
<h3>Health impacts</h3>
<p>A lot of people will get sick and somewhere between 1% and 10% of old and infirm people will die. Public health as a topic will be front and center in people's minds, favoring long-term advancements, such as better health-care funding and insurance. In the US in particular, there is a chance that we will get universal healthcare, but sadly enough it's not a done deal, by a long shot, even now. -- It's absurd.</p>
<p>Of all professions, expect healthcare to be hit hardest. The size of the infecting dose can strongly affect outcomes and healthcare workers are dealing with the sickest patients, while beset by overwork, exhaustion and shortages of protective equipment. In the near-to-midterm there will be worse health outcomes for everyone. Mid-to-longterm the bargaining position of healthcare professionals will be strengthened. Due to increased demand, we will see initiatives to make working in this field more attractive and ameliorate the inhumane conditions that workers are subject to. I expect job opportunities for public health specialists and epidemiologists, all the way from local government to hedge funds.</p>
<p>People with pre-existing illness will suffer. Particularly drug addicts may well find themselves in a desperate situation. With lockdowns and borders closed, supply will be tight. Also drug addicts generally need constant cash flow and have limited reserves - once commerce dries up many will find themselves unable to pay.</p>
<p>Isolation and deaths of despair will peak. People will get fat. Homeless people, of which we have many, will suffer incredibly. Most of the public places that they rely on for sanitation will be closed, shelters disease-riddled, food banks struggling and cash alms scarce.</p>
<h3>Culture</h3>
<p>Locking large swaths of the population at home for weeks will probably have a variety of cultural effects. These may be some of them</p>
<ul>
<li>Many will be bored. Expect anything that can capture people's attention to get lots of it (after the initial anxiety hype dies down).</li>
<li>Of course video conferencing will rule the world.</li>
<li>Streaming already is a popular genre, it will grow. As a medium for experiencing companionship, streaming may have its "mainstreaming" moment similar to when the boomer generation picked up facebook.</li>
<li>Some neighborhood ties will be strengthened. Today I attended a local "social distancing sing-along" on our street, this can be fun too!</li>
<li>A whole generation will come face-to-face with the basics of life: food, health, family, <em>death</em>. This is long overdue and to our betterment.</li>
<li>A lot of people will experience cognitive dissonance: Everything around you seems fine, the birds are chirping, and yet there is anxiety and extreme precaution. Look out for "hidden enemy" themes cropping up in movies and other popular narratives.</li>
</ul>
<p>The history of modern human society has been a history of a growing ability to shape our environment. We had a good run, but this age is very, very slowly coming to a close. We are entering a phase of history in which we get to experience, first hand, just how limited our power over nature is. We are learning that our attempts to control our environment are subject to the <a href="https://en.wikipedia.org/wiki/Diminishing_returns">law of diminishing returns</a>.</p>
<p>Every natural disaster, such as the COVID19 pandemic, serves as one lesson in our collective syllabus. Don't expect this course to be finished in our lifetime, but each step along the way, more people will take heed. As an example: The <em>negative returns</em> of complex, globalized supply-chains are becoming all too obvious. Not only will we repatriate industry, some of us will come out of this pandemic panic with a new-found appreciation for the energy efficiency, cost-effectiveness, resiliency and simple joy of having a small vegetable garden!</p>
<p>The inconvenience, sacrifice and true hardship of this pandemic may seem like a catastrophe. Anxiety itself will probably kill a number of people. Don't be one of them! Many Americans are still quite fortunate and have enough to eat and access to education and entertainment. Some people around us do not have such luxuries and we need to care for them, <em>pandemics are a team sport!</em> Ultimately we can count our blessings that the death rate of this disease is closer to the <a href="https://en.wikipedia.org/wiki/Spanish_flu">Spanish flu</a> and nothing like <a href="https://en.wikipedia.org/wiki/Ebola_virus_disease">Ebola</a> or the black death. We also are under the protection of a government that is strong enough to implement public health measures, as incompetent as it may sometimes seem.</p>
<h3>The broader picture</h3>
<p>Lockdown measures will give way to a new reality during and after the pandemic.
<em>If you're interested in <a href="posts/how-bad-will-it-be-economic-and-political-effects-of-covid19">the political and economic effects</a> checkout my <a href="posts/how-bad-will-it-be-economic-and-political-effects-of-covid19">part 2 article</a>.</em></p>
    </section><footer class="post-footer"><span>

              

        </span>
    </footer></article><article class="li post"><header class="post-header"><h3 class="post-title"><a href="posts/data-science-is-dying-out/">Data Science is dying out</a></h3>
        <p class="post-time"><time datetime="2020-02-24T01:50:26-06:00">2020-02-24 01:50</time>
        by
                Gabriel Pickard
        </p>
    </header><section class="post-excerpt"><p>As a Data Scientist you usually do one of two things:
1. You comb through a pile of numbers derived from a SQL database, S3 or an HDFS cluster, in order to answer questions like "what keeps customers from converting?" and make predictions like "How much is a given user worth?".
2. You build Machine Learning models that do actual ongoing work in deployed applications.</p>
<p>For both of these task groups there exists a different job title with similar job description:</p>
<ol>
<li>If you replace the SQL with Excel spreadsheets, then Analysts have been and still are answering the same kind of questions.</li>
<li>Software Engineers have been doing Machine Learning for a long time. Long enough that there now is such a thing as a Machine Learning Engineer.</li>
</ol>
<p>Data Scientists distinguish themselves from Analysts by knowing a bit more about programming. They distinguish themselves from Software Engineers by knowing less about programming. They differ from both in that Data Scientists usually are expected to have gone to grad school and know a thing or two more about math. </p>
<p>The "Data Scientist" job title was a way for industry to hire academics to do the kind of computational modeling that PhD candidates usually do in academia.
Also, it was a way for managers to feel cool, hip and with it.</p>
<p><strong>But it's dying.</strong></p>
<p>Why you say? Well, I'm glad you asked:</p>
<ol>
<li>Analysts can and do learn how to write SQL queries. Often (not always) the math involved in answering business questions can actually be kept relatively simple, you often don't need a PhD to do it. Doesn't hurt though, I guess.</li>
<li>Machine learning is getting commodified. You no longer need to write your own backpropagation algorithm in order to do Deep Learning. (It's sad, I know.) All you need is GPUs and money to burn. -- Well, and feature engineering, you do need feature engineering from time to time. And some experience in the field and domain knowledge. But all those can be acquired by many a bright individual.
Also, if your models are to do real work, they usually need to be integrated into real code. Here it comes in handy to know a thing or two about Software Engineering. Hence the rise in popularity of the ML Engineer.</li>
</ol>
<p>Now I know for a fact that once you give a group of people in the professional class a title and a decent salary, they'll make sure their field will continue to be needed, come hell or high water. So, in fact: <em>I lied.</em></p>
<p><strong>Sorry.</strong></p>
<p>Data Science is going nowhere, it's just that if you happen to not have Data Scientists on hand at your organization, <em>don't fret, you still can get stuff done.</em></p>
<p>But if you decide you do desperately need someone to make sweet, sweet Science to your Data; I'm a Sciencer of Data myself, possibly accepting clients. -- Or maybe I'm an ML Engineer, or something like that... Just give me a ring.</p>
    </section><footer class="post-footer"><span>

              

        </span>
    </footer></article><article class="li post"><header class="post-header"><h3 class="post-title"><a href="posts/developer-experience-fundamentally-harder-than-normal-ux/">Developer Experience: Fundamentally harder than normal UX</a></h3>
        <p class="post-time"><time datetime="2020-02-22T23:34:01-06:00">2020-02-22 23:34</time>
        by
                Gabriel Pickard
        </p>
    </header><section class="post-excerpt"><p>Many (maybe most) of us Software Engineers are deeply involved in projects where UI and UX are very important concerns (or at least they should be). Throughout the short history of our profession, we have become more and more focused on understanding and serving the people who will actually be subjected to the stuff we build:  <strong>users</strong>. In many cases, this focus on UI/UX isn't because we particularly enjoy worrying about such matters -- no, it's simply because we have to if we want to build successful products!</p>
<p>There has been tremendous growth in the field of UX/UI. Without a doubt, today's applications are much more user-friendly than those from 30 years ago. Back then, users were given  <strong>features</strong>, interface be damned. It was only over time that customers came to appreciate, expect, demand and reward those applications that actually cared to consider their needs.
<em>Consumer demand drove UX as a discipline</em>.</p>
<p>This process has been fast in some areas, slow in others. Nowhere has it been slower than in the realm of programming tools. We coders still put up with horrid UX/UI when programming.</p>
<p><img alt="Visual Studio" src="images/visual_studio.png" title="User Experiance"></p>
<h2>Why DX lags behind</h2>
<p>In my view the User Interface of programming encompasses a lot, from the type system of the programming language that you use, its error messages, to the editor you're writing code in, the websites you go to in order to get help, all the way to the cloud hosting systems you deploy on. Developer Interface / Developer Experience is comprised of all of this.</p>
<ul>
<li>Counter to any UI/UX philosophy, as programmers we find ourselves maintaining vast background knowledge about the structure and dynamics of our programs, with nary a visual cue to help us.</li>
<li>It's often so hard to figure out what <em>exactly</em> went wrong when something goes wrong.</li>
<li>A lot of tools are truly ugly!</li>
</ul>
<p>When was the last time you heard of a programming language discussed in terms of discoverability, succinctness, relevance, let alone beauty?</p>
<p>I believe there are two reasons for the discrepancy between general UX and DX:</p>
<p><img alt="ENIAC Computers" src="images/eniac1.jpg" title="The good old days"></p>
<ol>
<li>
<strong>Coding tools were around before UI/UX was a thing</strong>.
We've simply gotten used to them: Dealing with the idiosyncracies of bash, vi, or the JavaScript type system have become a part of the professional hazing process.
They may be suboptimal, <em>but they're ours!</em>
This is compounded by the fact that the history of technology is so path dependent. In so many cases it is much easier and more profitable to build on something existing rather than reinvent the wheel. -- Even if the existing wheel is full of arbitrary decisions and in fact impediments to what you are trying to do. Just look at the long reign of the x86 architecture, or consider the fact that basically all Operating Systems these days follow the Unix architecture. The fact that JavaScript is what it is. -- I don't mean to say that these technologies are without merit, however they also have considerable flaws and it has been more efficient to work with and around than to replace them entirely.
Certainly every mature technology will have to deal with technical debt in the inner workings of its guts. I have no bones with that. However, if the gory details are in the guts, then we coders are the GI surgeons having to deal with them. -- And we need sharper scalpels, better imaging and protective gear. In short: better tools.
<img alt="Chomsky Hierarchy" src="images/chomsky_hierarchy.png" title="Theoretical CS was fun">
</li>
<li>
<strong>Fundamentally, programming is a Turing Complete business.</strong>
You can view a UI as a form of (visual) formal language. For most GUIs the language complexity, the different states that the application interface can find itself in, would largely correspond to regular languages (some may be context-free, but that's pushing it). The visual languages are "flat", predictable, without feedback loops or long distance dependencies. It is in such an environment that UI/UX principles have been able to thrive.
But what did our <em>Intro to Theoretical CS</em> course teach us in college? You can't assume that statements about regular languages will still hold for Linearly Bounded Automata, let alone Turing Machines.
Fundamental principles in conventional UI/UX design no longer apply when it comes to programming. DI/DX is a very, very special case UI/UX.</li>
</ol>
<p>So, what I believe has happened is that in many cases we programmers have tilted at windmills of trying to improve our tooling -- the eternal yak shave -- only to be thwarted by the complexity of our own work, inevitably giving up and going with the most rudimentary system capable of doing the job somehow, even if it sucks.</p>
<h2>Toward better DX</h2>
<p><img alt="Ironman interface" src="images/futuristic_interface.jpeg" title="This could be us but you coding"></p>
<p>So, what's the alternative? Here are my suggestions for a world with better Developer Experience:</p>
<ol>
<li>
<em>Watch what coders actually do</em> -- this is one principle from UX that applies readily. Library developers rarely know what error messages users most commonly get stuck on; How about user studies? We track every click that people make on our website and agonize over button sizes, but know precious little about how common which call paths in our framework are. The elephant in the room here of course is privacy.</li>
<li>
<em>Address the many components that make up programming in concert</em>: Editor, shell, repl, language, version control host, cloud host and framework. Generally these pieces are not very aware of each other. There is some movement on this front: Microsoft is gearing up to tightly integrate VSCode, GitHub and Azure. This portends market domination. Competitors take note!</li>
<li>
<em>Search</em> -- It's our dirty little secret how much programming nowadays depends on Google. Arguable it is the most important item in our toolbelt. However, search engines nowadays do a uniquely poor job supporting developers. Most of recent Natural Language Understanding developments have made search less precise and less useful for coders, while hardly any new features have been added with our needs in mind. I find this topic fascinating and I'll be writing more about it-- coming up!</li>
<li>
<em>Standardize fundamental questions</em> -- How do I run this thing? Where does the code start? Is my system configured correctly? Project Readmes are hardly ever up to date. Why do we treat this as a moral failing instead of a usability issue?</li>
<li>
<em>Tests are a usability dead end</em>  -- I know this may be contentious, but I believe test suites are another realm of excessive moralizing en lieu of better tools and better processes. Too often they function as a security blanket that simply encases the parts of the code that are <em>unit testable</em>, while leaving the vulnerable, untestable bits fluttering in the wind. Approaches such as generative testing seem more promising.</li>
<li>
<em>Intelligently hide details</em> -- Writing code is about control, however understanding code is not. Most environments throw up their hands and overwhelm you with the entire pile of everything the program does, in minute detail. Others take a different tack and try to hide the bitter realities behind magic -- impenetrable and beautiful until you inevitably <em>do</em> have to care about what's behind the curtain. Why do we have so few systems that would allow us to zoom in and out? <em>Get you a coding environment that can do both</em>.</li>
<li>
<em>Coding is a social process</em> -- The success of GitHub is a testament to this. I'm not sure, but maybe we can do even better along these lines.</li>
<li>
<em>Programming Languages are User Interfaces</em> -- The most fundamental unit of Developer Experience is the programming language. The Elm language is one of few examples where this reality was considered explicitly in the design process.</li>
<li>
<em>Programming is about empowering</em> -- dumbing things down is <em>not</em> enough. I believe minimalism is a cheap approach to UX in general, but it definitely doesn't work for DX -- it fundamentally misses the point of what programming is about: expressive power. I believe this is why many "graphical"/beginner programming languages have failed.</li>
<li>
<em>Engage with Theoretical Computer Science</em> -- In a way we are hunting for UI widgets (or other kinds of artifacts) that can faithfully represent the full computational complexity of algorithms. I have been actively working on this front and it's a long term project that you hopefully will be hearing more about. Representing computational complexity is also the one area where <a href="http://worrydream.com/">Bret Victor's</a> excellent work may have fallen short of what we ultimately need.</li>
</ol>
<p><img alt="UX Meme" src="images/why-ux-research-is-important.png" title="Just ship it!"></p>
<h2>DX is worth it</h2>
<p>Interest in this topic is growing. It's definitely worth looking into. The software industry is so big and expensive that even small improvements can have considerable impact. Furthermore, Software Engineers actually <em>do</em>  respond to better UX -- and they wield considerable purchasing power. Consider the following example:</p>
<p>I once worked at a small company, which for regulatory reasons couldn't use the normal cloud-hosted GitHub. Our engineering department strong-armed the rest of the company to purchase on-premise GitHub Enterprise at a cost equivalent to hiring one or two additional engineers, <em>just so we could use Pull-Requests!</em> We recognized the difference it made in our productivity and we demanded it -- only the best of tools would do.</p>
    </section><footer class="post-footer"><span>

              

        </span>
    </footer></article><article class="li post"><header class="post-header"><h3 class="post-title"><a href="posts/i-declare-blog/">I declare blog</a></h3>
        <p class="post-time"><time datetime="2020-02-22T13:51:46-06:00">2020-02-22 13:51</time>
        by
                Gabriel Pickard
        </p>
    </header><section class="post-excerpt"><p>This is yet another attempt I'm making to start a blog. This time will be different!
Also this is a test post.</p>
    </section><footer class="post-footer"><span>

              

        </span>
    </footer></article>
</div>
</main><footer id="site-footer"><div class="container">
            <p>Contents © 2023         <a href="mailto:info@gabrielpickard.com">Gabriel Pickard</a>  </p>
            
        </div>
    </footer><!-- Social buttons --><div id="addthisbox" class="addthis_toolbox addthis_peekaboo_style addthis_default_style addthis_label_style addthis_32x32_style">
<a class="addthis_button_more">Share</a>
<ul>
<li>
<a class="addthis_button_facebook"></a>
</li>
<li>
<a class="addthis_button_google_plusone_share"></a>
</li>
<li>
<a class="addthis_button_linkedin"></a>
</li>
<li>
<a class="addthis_button_twitter"></a>
</li>
</ul>
</div>
<script src="https://s7.addthis.com/js/300/addthis_widget.js#pubid=ra-4f7088a56bb93798"></script><!-- End of social buttons --></main></body>
</html>
